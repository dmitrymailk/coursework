{"title": "Graph Theory | BFS Shortest Path Problem on a Grid", "data": [{"type": "sentence", "content": "I hope you have an idea about what is Breadth First Search (BFS) and how it works because we would be using the BFS concepts intensively."}, {"type": "subtitle", "content": "Setting the Scene"}, {"type": "sentence", "content": "Many problems in Graph Theory could be represented using grids because interestingly grids are a form of implicit graph. We can determine the neighbors of our current location by searching within the grid. A type of problem where we find the shortest path in a grid is solving a maze, like below."}, {"type": "image", "content": "https://miro.medium.com/max/1598/1*730G0YUHgl1M-e3AKIG9oQ.png"}, {"type": "sentence", "content": "Another example could be routing through obstacles (like trees, rivers, rocks etc) to get to a location."}, {"type": "subtitle", "content": "Graph Theory on Grids"}, {"type": "sentence", "content": "A common approach to solve graph problems is to first convert the structure into some representational formats like adjacency matrix or list. Basically, these are data structures which store the neighborhood information within the graph. Let\u2019s see a more intuitive version of it."}, {"type": "sentence", "content": "Consider we have an imaginary graph."}, {"type": "image", "content": "https://miro.medium.com/max/1368/1*pWvX_se6vLHJeAsBRnIrvw.png"}, {"type": "sentence", "content": "No, this is not a graph. Look at figure 1, but that\u2019s what I was talking about. Imagine that every cell in figure 1 has neighbors to it\u2019s left, right, bottom and up. For more clarity, cell 0 has two neighbors, 1 and 2. In the same way, cell 4 also has two neighbors 2 and 3. We can review these cells as the vertices in a graph where rows * columns would be the total number of vertices. Figure 2 is the adjacency list representing our imaginary graph, now you can relate it with the first figure, right? The last figure depicts the adjacency matrix of the same graph. Every cell (i, j) of adjacency matrix is filled with 1s where nodes i and j have an edge in between them. We used just 1s and 0s here because we have no information about the cost from vertex i to j. If we had that, we could have used that information, as well."}, {"type": "sentence", "content": "Once we have an adjacency list/matrix representation of a graph, we can run multiple graph algorithms on top it to solve different use cases like finding the shortest path and connected components."}, {"type": "subtitle", "content": "Dungeon Problem"}, {"type": "sentence", "content": "This is probably a problem statement we have encountered in many interviews and programming competitions and it goes as follows."}, {"type": "image", "content": "https://miro.medium.com/max/680/1*wc2rqOjmkNONX3MP0LK3_w.png"}, {"type": "sentence", "content": "The dungeon has a size of R x C where R is number of rows and c is number of columns. We have to start at cell \u2018S\u2019 and we have an exit at cell \u2018E\u2019. The number (#) symbol depicts the roadblocks in the route and period (.) shows an open route."}, {"type": "image", "content": "https://miro.medium.com/max/678/1*RDvOt5Yht91om1icvwTFUg.png"}, {"type": "sentence", "content": "In the given setup, one solution could be drawn as above in the green route. Our approach is to do a BFS starting from cell S, until we find the exit cell E."}, {"type": "image", "content": "https://miro.medium.com/max/1522/1*ws2IewvSdJd3bbhZd-b9uQ.png"}, {"type": "sentence", "content": "If you remember, we used a queue to store the points to be visited later in the graph. We use the same here too. We start from cell (0,0) and add it to our queue. Once it\u2019s visited we add all the neighbors of the visited cell to the queue. Cell (0,0) has two neighbors, (0,1) and (1,0). The queue becomes bigger and bigger as we visit and add more neighbors into the queue, iteratively. We stop this process when we meet the exit condition i.e. we visit the exit cell E (4,3). Then we can regenerate the path from Exit to Start by backtracking."}, {"type": "subtitle", "content": "Alternative State Representation"}, {"type": "sentence", "content": "We have been using a single queue to keep track of the next node to be visited say a (i, j) pair, so far. But this is not the best approach to follow, because it requires a lot of packing and unpacking to and forth the queue. Instead, let\u2019s try another better method which scales really well with higher dimensional data, also possesses less complexity."}, {"type": "sentence", "content": "An alternative method would be to use separate queues for every dimensions, so in a 3D grid, we would have one queue for each dimension."}, {"type": "image", "content": "https://miro.medium.com/max/1048/1*Q4jpf418CCdk1Jg0K2vMrg.png"}, {"type": "sentence", "content": "As soon as we enqueue some potential information into the queue, x, y and z would go to respective queues. In the same way, dequeue retrieves a triplet of (x,y,z) values at a time."}, {"type": "subtitle", "content": "Pseudo Code to Solve the Dungeon Problem"}, {"type": "sentence", "content": "We start by initializing some global variables. R and C stand for number rows and columns of the dungeon, respectively. The variable m is the input character matrix of size R x C. We store the initial row and column values where we store the starting point of our BFS in variables sr and sc. We use two separate queues rq and cr to store the respective row and column indices of the next node to be visited. Also, we use a couple of variables to keep track of total steps taken to reach the end. nodes_left_in_layer shows the count that how many nodes we have to dequeue before we take a step further and nodes_in_next_layer tracks how many nodes we have added in the BFS expansion, so that we can update nodes_left_in_layer accordingly. The variable reached_end stores whether we already reached the exit cell or not. The variable visited is a matrix of size R x C which is used to mark the cells visited, because we don\u2019t want to visit the same cell again. Variables dr and dc need some explanation, I will cover it soon."}, {"type": "image", "content": "https://miro.medium.com/max/384/1*rzzBtU_a75Wha44Bfbh_zw.png"}, {"type": "sentence", "content": "Suppose we are in the red cell (i, j). We have an assumption like a row index can only move between rows and a column index can move between columns. So the only possible row operation is either we can go North by subtracting 1 from i or move South by adding 1 to i. In the same way, we are restricted to move either East or West by adding or subtracting 1 to the column index i.e. j. We use different combinations of direction values to move around the dungeon and that\u2019s why defined it before as variables. I think you got the point."}, {"type": "sentence", "content": "We\u2019re not done with the problem yet. We just defined a couple of important variables only. The core idea is about to come out."}, {"type": "sentence", "content": "Here I have defined two functions namely solve() and explore_neighbors(). We start by enqueuing the initial (i, j) positions from where we start the BFS process and we mark the cell as visited."}, {"type": "sentence", "content": "Then we do the following steps iteratively until either rq or cq becomes empty."}, {"type": "sentence", "content": "5. We enqueue the values of current cell and mark it as visited. (Don\u2019t forget, we are inside the explore_neighbors() function call). What happens here is like, we try moving to all possible locations such as north, east, south and west. We then iteratively explore its neighbors. That\u2019s it."}, {"type": "sentence", "content": "6. Finally, we update the value of nodes_in_next_layer and leave."}, {"type": "sentence", "content": "7. We update a couple of parameters to keep track of how many steps we took so far."}, {"type": "sentence", "content": "8. As soon as we serve an exit point, we go out."}, {"type": "sentence", "content": "TADAAA!!!"}, {"type": "sentence", "content": "The whole idea and the algorithm are relatively super easy even the pseudo-code looks scary."}, {"type": "sentence", "content": "We started looking at how a maze works and how we can port the same problem into a more scientific one. We saw how we could use grids and adjacency lists to represent the problem. We understood what\u2019s a dungeon problem and how it\u2019s solved using BFS. My idea was to show how we can use BFS to solve a shortest path problem on a grid. That\u2019s pretty much all about it."}, {"type": "sentence", "content": "In the next post, we will have an Introduction to tree algorithms. Until then, bye."}, {"type": "image", "content": "https://miro.medium.com/max/2000/1*lgzROdVHD1jDW91xwO8mVA.png"}], "topic": "artificial-intelligence"}