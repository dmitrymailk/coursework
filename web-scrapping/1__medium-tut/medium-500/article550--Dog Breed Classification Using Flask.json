{"title": "Dog Breed Classification Using Flask", "data": [{"type": "subtitle", "content": "Dog Breed Classifier web app demonstrating the use of Transfer Learning with ResNet-50"}, {"type": "sentence", "content": "A simple dog breed classification web application that detects the breed of the dog among 133 categories. Also, if the uploaded image is that of a human, the algorithm outputs the dog breed the human resembles the most."}, {"type": "subtitle", "content": "Overview"}, {"type": "sentence", "content": "The dog breed classification project of the Data Scientist Nanodegree by Udacity. A simple web application is developed using Flask through which the user can check if an uploaded image is that of a dog or human. Also, if the uploaded image is that of a human, the algorithm tells the user what dog breed the human resembles the most. The Deep Learning model distinguishes between the 133 classes of dogs with an accuracy of over 82.89%."}, {"type": "subtitle", "content": "Domain Background"}, {"type": "sentence", "content": "The project involves Image Processing, classification and detection using Deep Learning. Convolutional Neural Networks along with Transfer Learning is used to deliver the results. Given an image of the dog, the CNN must give out the correct breed of the dog in the image out of 133 classes of dogs. All this functionality is provided using a web application which is developed using Flask."}, {"type": "subtitle", "content": "Problem Statement"}, {"type": "sentence", "content": "The aim of this project is to create a classifier that is able to identify a breed of a dog if given a photo or image as input. If the photo or image contains a human face, then the application will return the breed of dog that most resembles the person in the image. I decided to opt for this project as the Capstone project of Udacity Data Scientist Nanodegree as I found the topic of Deep Neural Networks to be very fascinating and wanted to dive deeper into this with some practical work."}, {"type": "subtitle", "content": "Dataset Exploration"}, {"type": "sentence", "content": "Two datasets i.e. Dog Dataset and Human Dataset are used which are provided by Udacity. Dog dataset contains images of 133 classes of dogs in 133 folders each. The links to both the datasets are given below:"}, {"type": "sentence", "content": "While exploring the dataset, some useful insights that I found are given below:"}, {"type": "subtitle", "content": "Solution Statement"}, {"type": "sentence", "content": "The steps that I used in the solution approach are given below:"}, {"type": "subtitle", "content": "Libraries Used"}, {"type": "sentence", "content": "The libraries and packages alongwith their appropriate versions that I used in this project are described below. I would recommend to make a separate environment for these packages, as installing them in your system alongwith other pre-installed packages might cause some version errors. I used Anaconda in my Ubuntu desktop to create a new virtual environment called \u201cdog-breed\u201d."}, {"type": "subtitle", "content": "Detecting Humans"}, {"type": "sentence", "content": "I used OpenCV\u2019s implementation of feature based Haar Cascade Classifiers available on the Internet to easily detect humans in an image as the first major step of the pipeline. OpenCV provides many pre-trained face detectors, stored as XML files on github. I downloaded one of these one of these detectors and stored it in the haarcascades directory."}, {"type": "sentence", "content": "Converted the input image to grayscale because it is a standard procedure to convert the images to grayscale before using any of the face detectors. The detectMultiScale function executes the classifier stored in face_cascade which takes the grayscale image as a parameter. Also, added a bounding box to each detected face in the image. An output from the above step is given below:"}, {"type": "image", "content": "https://miro.medium.com/max/534/1*tmqJ5w-vcMJF2lFr3_d0oA.png"}, {"type": "subtitle", "content": "Writing a human face detector"}, {"type": "sentence", "content": "I used the same procedure to write a function that detects humans in an image and returns True if a human face is detected and False otherwise. This function, aptly named face_detector, takes a single string-valued file path to an image as input and appears in the code block below."}, {"type": "subtitle", "content": "Detecting Dogs"}, {"type": "sentence", "content": "In this step, I used a pre-trained ResNet-50 model to detect dogs in the input images. The first line of code beloe downloads the ResNet-50 model, along with weights that have been trained on ImageNet, a very large and popular dataset used for image classification and other computer vision tasks. ImageNet contains over 10 million URLs, each linking to an image containing an object from one of 1000 categories. Given an image, this pre-trained ResNet-50 model returns a prediction (derived from the available categories in ImageNet) for the object that is contained in the image."}, {"type": "subtitle", "content": "Pre-processing the Input Data"}, {"type": "sentence", "content": "When using TensorFlow as the backend, Keras CNNs require a 4D array as input, with shape (nb_samples, rows, columns, channels), where nb_samples corresponds to the total number of images (or samples), and rows, columns, and channels correspond to the number of rows, columns, and channels for each image, respectively."}, {"type": "sentence", "content": "The path_to_tensor function below takes a string-valued file path to a color image as input and returns a 4D tensor suitable for supplying to a Keras CNN. The function first loads the image and resizes it to a square image that is 224x224 pixels."}, {"type": "sentence", "content": "Next, the image is converted to an array, which is then resized to a 4D tensor. In this case, since we are working with color images of dogs, each image has three channels. Likewise, since we are processing a single image (or sample), the returned tensor will always have shape (1, 224, 224, 3)."}, {"type": "sentence", "content": "The paths_to_tensor function given below takes a numpy array of string-valued image paths as input and returns a 4D tensor with shape (nb_samples, 224, 224, 3)."}, {"type": "sentence", "content": "Here, nb_samples is the number of samples, or number of images, in the supplied array of image paths. It is best to think of nb_samples as the number of 3D tensors (where each 3D tensor corresponds to a different image) in our dataset!"}, {"type": "subtitle", "content": "Making Predictions with ResNet-50"}, {"type": "sentence", "content": "At this stage, a 4D tensor is ready for the ResNet-50 to make predictions. Now that we have a way to format our image for supplying to ResNet-50, we are now ready to use the model to extract the predictions. This is accomplished with the predict method, which returns an array whose i-th entry is the model\u2019s predicted probability that the image belongs to the i-th ImageNet category. This is implemented in the ResNet50_predict_labels function below."}, {"type": "subtitle", "content": "Writing a Dog Detector"}, {"type": "sentence", "content": "While looking at the dictionary of the ImageNet labels, I noticed that the categories corresponding to dogs appear in an uninterrupted sequence and correspond to dictionary keys 151\u2013268, inclusive, to include all categories from 'Chihuahua' to 'Mexican hairless'. Thus, in order to check to see if an image is predicted to contain a dog by the pre-trained ResNet-50 model implemented above, we need to only check if the ResNet50_predict_labels function above returns a value between 151 and 268 (inclusive)."}, {"type": "sentence", "content": "I used these ideas to make the dog_detector function below, which returns True if a dog is detected in an image (and False if not)."}, {"type": "subtitle", "content": "Creating a CNN to Classify Dog Breeds (from Scratch)"}, {"type": "sentence", "content": "Now that we have functions for detecting humans and dogs in images, we need a way to predict dog breed from images. Considering this fact, that even a human would have great difficulty in distinguishing between a Brittany and a Welsh Springer Spaniel given below."}, {"type": "image", "content": "https://miro.medium.com/max/900/1*k6x2Q3yYj5C2e3FV5FejAQ.jpeg"}, {"type": "image", "content": "https://miro.medium.com/max/1000/1*YO-dHKHlrBSirPhe89edWA.jpeg"}, {"type": "sentence", "content": "Also, more distinguishing/challenging categories are shown below for reference."}, {"type": "image", "content": "https://miro.medium.com/max/1284/1*7sD_K3C7c48ywR4l5UHhfQ.png"}, {"type": "subtitle", "content": "Pre-processing the Data"}, {"type": "sentence", "content": "I rescaled the images by dividing every pixel in every image by 255. The corresponding code is given below for reference."}, {"type": "subtitle", "content": "Model Architecture used"}, {"type": "sentence", "content": "After so many attempts, I came up with a model architecture that performed really well. Added six convolutional layers with \u201crelu\u201d activation followed by a flattening and two dense layers. The exact code snippet is provided below."}, {"type": "sentence", "content": "The model architecture is given below for further reference. The total parameters and trainable parameters comes out to be 258,981."}, {"type": "subtitle", "content": "Compiling and Training the Model"}, {"type": "sentence", "content": "I used \u201crmsprop\u201d optimizer and \u201closs=categorical_crossentropy\u201d for now. I used accuracy in compiling the model as it is suitable for this kind of problem. Also, analysis can be done on F1 score as well because this dataset is imbalanced and for minority classes F1 score would produce more realistic results."}, {"type": "sentence", "content": "I used epochs=25 and batch_size=20. Also, used model checkpointing to save the model that attains the best validation loss."}, {"type": "subtitle", "content": "Testing the Model"}, {"type": "subtitle", "content": "Creating a CNN to Classify Dog Breeds (using Transfer Learning)"}, {"type": "sentence", "content": "I used transfer learning to create a CNN using ResNet-50 bottleneck features. After downloading the bottleneck features for the ResNet-50 model, I extracted the bottleneck features corresponding to the train, test, and validation sets by running the following in the code block below:"}, {"type": "subtitle", "content": "Model Architecture"}, {"type": "sentence", "content": "Appended the GlobalAveragePooling2D layer to the trained \u201cResNet_Model\u201d made with the corresponding \u201cbottleneck_features\u201d followed by the dense layer with activation \u201csoftmax\u201d. The final layer contains 133 nodes as there are total 133 different dog breed classes in the dataset. The code of the model is given below:"}, {"type": "sentence", "content": "I used the ResNet50 model and the last output layer of this model is changed so as to predict 133 different classes of dogs. The architecture of the model is depicted below and the total number of parameters are equal to 272,517."}, {"type": "subtitle", "content": "Training and Testing the Model"}, {"type": "sentence", "content": "I used categorical crossentropy loss in addition to the \u201cadam\u201d optimizer in this transfer learning approach."}, {"type": "sentence", "content": "Peformed training of the model in the code cell below. I used model checkpointing to save the model that attains the best validation loss. Batch_size is set to 20 and the number of epochs is equal to 25."}, {"type": "sentence", "content": "After loading the model with the best validation loss using \u201cload_weights\u201d method, I tried out my model on the test dataset of dog images. The below code is given for reference."}, {"type": "subtitle", "content": "Predicting Dog Breed with ResNet-50 Model"}, {"type": "sentence", "content": "Writing a function that takes an image path as input and returns the dog breed (Affenpinscher, Afghan_hound, etc) that is predicted by our model."}, {"type": "subtitle", "content": "The Algorithm"}, {"type": "sentence", "content": "Witten an algorithm that accepts a file path to an image and first determines whether the image contains a human, dog, or neither. Then,"}, {"type": "subtitle", "content": "Testing the Algorithm on sample images"}, {"type": "sentence", "content": "The output is better than I expected :) Also if the human face in the picture has distinct features, the predicted dog race matches very well. However for very close-looking dog races, it still seems to be tricky to get it right. For improving the algorithm, we could increase the training data by including more pictures per dog breed. We could include more and deeper layers into our CNN. This would also lead to a decreased performance or require better hardware in order not to slow down processing time. Also, we could run different CNNs against each other to see which one performs best for this task."}, {"type": "sentence", "content": "Sample image 1 for testing the pipeline:"}, {"type": "image", "content": "https://miro.medium.com/max/456/1*J4Raw_ojQM7yFZuAoQrW6w.png"}, {"type": "sentence", "content": "Sample image 2 for testing the pipelime:"}, {"type": "image", "content": "https://miro.medium.com/max/382/1*Aqncs615GMwTn2E4Pp-9jQ.png"}, {"type": "sentence", "content": "Sample image 3 for testing the pipeline:"}, {"type": "image", "content": "https://miro.medium.com/max/666/1*WvYug6NwUXB-tLGKss9vfA.png"}, {"type": "subtitle", "content": "Web Application Using Flask"}, {"type": "sentence", "content": "I integrated the above code into a simple web application using flask to carry out the dog breed predictions. For this, I converted the \u201cdog_names\u201d array to a \u201cjson file\u201d and imported it into my flask application by the below code."}, {"type": "subtitle", "content": "Steps for running the web application"}, {"type": "sentence", "content": "For running the web application on local machine, the following instructions should be followed:"}, {"type": "sentence", "content": "Go to http://0.0.0.0:8080/ to view the web app and input new pictures of dogs or humans \u2014 the app will tell you the resembling dog breed successfully without any errors."}, {"type": "subtitle", "content": "Prediction Using Flask"}, {"type": "sentence", "content": "Below, I have attached some screenshots that depict the working of my web app. The user can upload an image on the homepage and click the \u201cUpload and Detect Dog button\u201d. The next page displays the detected breed successfully."}, {"type": "image", "content": "https://miro.medium.com/max/2732/1*bWy_yTL0OeJQilWZ-It_1A.png"}, {"type": "sentence", "content": "Results about the prediction are shown on the next page."}, {"type": "image", "content": "https://miro.medium.com/max/2732/1*ITLQzV2tV5O85yOOM95ZNA.png"}, {"type": "image", "content": "https://miro.medium.com/max/2732/1*FKkjFgdb2OfqN9tmkZN6Fg.png"}, {"type": "subtitle", "content": "Conclusion"}, {"type": "sentence", "content": "I was surprised by the good results of the algorithm and the model i.e. Resnet50. Without doing too much fine-tuning, the algorithm provides high accuracy and the predictions were mostly correct. An accuracy of 82.8947%. For human faces it seems easier if the face has distinct features that resembles a certain dog breed. Otherwise, it starts to guess from some features, but the results vary. For higher accuracy, the parameters could be further optimized, maybe also including more layers into the model. Further, number of epochs could be increased to 40 to lower the loss. Also by providing an even bigger training data set, the classification accuracy could be improved further. Another improvement could be made with regard to UI."}, {"type": "subtitle", "content": "References"}, {"type": "sentence", "content": "2. ImageNet is an image database in which each node of the hierarchy is depicted by hundreds and thousands of images organized according to the WordNet hierarchy."}, {"type": "sentence", "content": "3. More information about the feature based Haarcascade classifier that we used for detecting faces in the input image can be found on the below source."}, {"type": "sentence", "content": "The project can be found on my GitHub Repository with detailed instructions. Main.py contains detailed code about the functioning of the web application and the deep learning model used."}, {"type": "sentence", "content": "And with that, we have come to the end of this article. Bundle of thanks for reading it!"}, {"type": "sentence", "content": "My Portfolio and Linkedin :)"}], "topic": "data-science"}