{"title": "Declare Your First Python Class \u2014 Understand 3 Basic Components", "data": [{"type": "subtitle", "content": "Python Basics"}, {"type": "subtitle", "content": "Better organize your code using custom classes"}, {"type": "image", "content": "https://miro.medium.com/max/6000/0*-cp54P2ybx_GZwbI"}, {"type": "sentence", "content": "When our project\u2019s scope grows, we\u2019ll find it gradually tedious to manage data using built-in data types. For example, let\u2019s say we\u2019re building an employee management tool, and thus we\u2019ll need to deal with data related to individual employees. Using the built-in dictionary data type, we\u2019ll have to use the following data structure (i.e., dictionary) to refer to a particular employee."}, {"type": "sentence", "content": "Say that we want to access this employee\u2019s information, we\u2019ll have to use the square brackets to retrieve particular values."}, {"type": "sentence", "content": "It\u2019s all good if we\u2019re careful enough to spell the keys correctly. However, if we misspell the key, the corresponding value can\u2019t be retrieved. Moreover, our program can even crash. Although many advanced Python editors, such as Visual Studio Code and PyCharm, have the intelligent code feature, they don\u2019t always offer hints about the keys for dictionaries."}, {"type": "sentence", "content": "What\u2019s the better alternative?"}, {"type": "sentence", "content": "The custom class comes to the rescue! Declaring a custom class is very straightforward in Python, which you\u2019ll find shortly. When we declare a custom class, we\u2019re basically drawing a blueprint on what data (e.g., attributes) these classes can store and what functionalities (e.g., methods) they can provide. Importantly, these attributes and methods are accessible using the more slick dot notation and they\u2019re supported by intelligent code hinting by most modern integrated development environments \u2014 more commonly known as IDE."}, {"type": "sentence", "content": "In this article, let\u2019s see how we can take advantage of creating a custom class to manage the data. Specifically, we\u2019ll focus on three basic components that most custom classes will implement."}, {"type": "subtitle", "content": "1. Instantiation"}, {"type": "sentence", "content": "The very first thing that we need to understand is that the purpose of creating custom classes is that we can create instance objects of these classes. Most of the time, it\u2019s the instance objects (or simply referred to as instances) that actually store the data and perform desired operations."}, {"type": "sentence", "content": "The process of creating an instance is known as instantiation. In other words, we instantiate an instance object of the class. In most cases, we use the class constructor to create an instance. Too much jargon here? No problem! Let\u2019s see some examples to understand all of them."}, {"type": "sentence", "content": "In the above code, we declared a custom class called Employee. As you can see, we defined a function called __init__, which means initialization. In Python, a function with a double-underscore prefix and a double-underscore suffix is known as a magic function. When we say magic, it means that it has some special meanings. In this case, the __init__ is reserved as the constructor method in Python. We\u2019ll talk about what the self in the function means in the next section."}, {"type": "sentence", "content": "What\u2019s a constructor method? The construction just means the creation of an instance object. In the above code, we simply use a pair of parentheses following the class name to create the instance. If you want to learn more about the instantiation process about Python classes, you can refer to my previous article on this topic."}, {"type": "sentence", "content": "To verify the variable employee has the desired type, we can use some built-in introspection functions, including type() and isinstance(), as shown below."}, {"type": "subtitle", "content": "2. Attributes"}, {"type": "sentence", "content": "In the above section, we declared a class, but our class couldn\u2019t really do anything. One problem is that the instances can\u2019t store any data. For example, in the beginning, the dictionary object stores some basic information for the employee."}, {"type": "sentence", "content": "The purpose of creating the custom class Employee is to make our data management job easier, isn\u2019t it? It brings us to the introduction of attributes for the class. Let\u2019s see an updated version of the Employee class."}, {"type": "sentence", "content": "As shown in the above code, besides the self argument, the updated initialization method takes name, employee_id, and gender arguments. What does self mean here? In essence, it refers to the newly created instance object, such that we can set its corresponding attributes (e.g., self.name). To learn more about the self argument, please refer to my previous article."}, {"type": "sentence", "content": "With the updated initialization method, we\u2019ll call the constructor method by providing needed parameters, like blow. Again, we don\u2019t need to specify the self argument, because Python implicitly sets the newly created instance as the self argument (see the above article for more information)."}, {"type": "sentence", "content": "As I mentioned above, one reason that we want to use custom classes is the convenience of accessing attributes using the dot notation. In addition, we can change them if we want to. Let\u2019s see some examples below."}, {"type": "sentence", "content": "One thing to note is that we refer to these above-defined attributes as instance attributes, which means that these attributes belong to a particular instance. A different instance object can have different attributes, as shown below."}, {"type": "sentence", "content": "In addition to instance attributes, we can also declare class attributes. Unlike instance attributes that are instance-specific, class attributes are \u201cowned\u201d by the class (remember class is also an object in Python such that it can have attribute). Importantly, instances can access these class attributes directly, which is usually illegal in other programming languages (e.g., Swift). In these languages, only the class itself can use the class attributes directly."}, {"type": "sentence", "content": "As shown in the code, the updated class has a class attribute called company. Notice that the new instances and the class all have access to the class attribute. Moreover, we can change the class attribute, as shown below."}, {"type": "subtitle", "content": "3. Methods"}, {"type": "sentence", "content": "Now, our class is able to store data and we can retrieve and change their attributes as needed, what else do we need?"}, {"type": "sentence", "content": "Some functions. That\u2019s right. Our custom class isn\u2019t able to perform any operations, and let\u2019s fix that."}, {"type": "sentence", "content": "In the code above, for demonstration purposes, we created two simple methods, namely request_vacation and send_notice. As noted by the comments, the first function is an instance method, which means that the caller is an instance object of the class. Notice the use of self argument in the function declaration? That\u2019s the indication of an instance method in Python. It\u2019s a convention to use self to refer to an instance object of a class."}, {"type": "sentence", "content": "The second function is a static method, which means that the caller is the class itself (although technically an instance can call this function too, pretty much like a class attribute as discussed above). The static method is sometimes also called a class method in other programming languages, but they\u2019re not exactly the same in Python, the discussion of which is beyond the current article\u2019s scope. By the way, @staticmethod is known as a decorator function that is used to declare a static method in a class. You can learn more about decorators in my previous article."}, {"type": "sentence", "content": "Let\u2019s see how we can call these methods."}, {"type": "sentence", "content": "As explained above, we created an instance, and the instance can call both the instance and static method. The class itself can call the static method, which I recommend should be the preferred way to use a static method, because it doesn\u2019t need to create an instance and minimize confusion (i.e., a static method doesn\u2019t rely on any instances)."}, {"type": "sentence", "content": "What will happen if we try to use the class to call the instance method?"}, {"type": "sentence", "content": "Apparently, the function call didn\u2019t succeed, because Python will look for the instance object and assign it to the self argument. So, please don\u2019t make this mistake."}, {"type": "subtitle", "content": "Conclusions"}, {"type": "sentence", "content": "In this article, we reviewed how to declare a custom class in Python. Specifically, we covered the most basic elements that we usually implement in a custom class declaration. Here\u2019s a quick recap."}], "topic": "data-science"}